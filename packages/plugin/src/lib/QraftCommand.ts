import c from 'ansi-colors';
import { Command } from 'commander';
import { sep } from 'node:path';
import process from 'node:process';
import { pathToFileURL, URL } from 'node:url';
import ora, { Ora } from 'ora';

import { GeneratorFile } from './GeneratorFile.js';
import { handleSchemaInput } from './handleSchemaInput.js';
import { getDocumentServices } from './open-api/getDocumentServices.js';
import { type Service } from './open-api/getServices.js';
import { OpenAPISchemaType } from './open-api/OpenAPISchemaType.js';
import { readSchema } from './open-api/readSchema.js';
import { OutputOptions } from './OutputOptions.js';
import { writeGeneratorFiles } from './writeGeneratorFiles.js';

export class QraftCommand extends Command {
  private readonly cwd: URL;

  constructor() {
    super();
    this.cwd = pathToFileURL(`${process.cwd()}/`);

    this.usage('[input] [options]')
      .argument(
        '[input]',
        'Input OpenAPI Document file path, URL (json, yml)',
        null
      )
      .requiredOption(
        '-o, --output-dir <path>',
        'Output directory for generated services'
      )
      .option(
        '-rm, --clean',
        'Clean output directory before generating services'
      )
      .option(
        '--filter-services <glob-pattern>',
        'Filter services to be generated by glob pattern. Eg: "/user/**,/post/**". See NPM `micromatch` package for more details.'
      )
      .option(
        '--postfix-services <string>',
        'Postfix to be added to the generated service name (eg: Service)'
      )
      .option(
        '--service-name-base <endpoint[<index>] | tags>',
        'Use OpenAPI Operation `endpoint[<index>]` path part (e.g.: "/0/1/2") or `tags` as the base name of the service.',
        'endpoint[0]'
      );
  }

  action(callback: QraftCommandActionCallback): this {
    return super.action(async (...actionArgs) => {
      const { version: packageVersion } = await import(
        '@openapi-qraft/plugin/package.json',
        {
          assert: { type: 'json' },
        }
      ).then(({ default: packageJSON }) => packageJSON);

      const inputs = actionArgs.filter(
        (arg) => typeof arg === 'string'
      ) as string[];
      const args = actionArgs.find(
        (arg) => arg && typeof arg === 'object'
      ) as Record<string, any>;

      if (!args) throw new Error('Arguments object not found');

      if (args.version) {
        console.info(`v${packageVersion}`);
        process.exit(0);
      }

      console.info(`✨ ${c.bold(`OpenAPI Qraft ${packageVersion}`)}`);

      const spinner = ora('Starting ⛏︎').start();

      const input = handleSchemaInput(inputs[0], this.cwd, spinner);

      spinner.text = 'Reading OpenAPI Schema';
      const schema = await readSchema(input);

      spinner.text = 'Getting OpenAPI Services';
      const services = await getDocumentServices({
        schema,
        output: {
          postfixServices: args.postfixServices,
          serviceNameBase: args.serviceNameBase,
        },
        servicesGlob: parseServicesFilterOption(args.filterServices),
      });

      spinner.text = 'Generating code';

      await new Promise<void>((resolve, reject) => {
        callback(
          {
            inputs,
            args,
            spinner,
            services,
            schema,
            output: {
              dir: normalizeOutputDirPath(args.outputDir),
              clean: args.clean,
            },
          },
          async function resolveGeneratorFiles(fileItems) {
            try {
              await writeGeneratorFiles({
                fileItems,
                spinner,
              });
              spinner.succeed(c.green('Qraft has been finished'));
              resolve();
            } catch (error) {
              spinner.fail(c.red('Error occurred during generation'));

              if (error instanceof Error) {
                console.error(c.red(error.message), c.red(error.stack ?? ''));
              }

              reject(error);
            }
          }
        )?.catch(reject);
      });
    });
  }
}

/**
 * Normalize an output directory path by adding trailing slash
 */
function normalizeOutputDirPath(outputDir: string): URL {
  return pathToFileURL(
    outputDir.endsWith(sep) ? outputDir : `${outputDir}${sep}`
  );
}

/**
 * Parse services filter option to array
 * @example
 * ```ts
 * parseServicesFilterOption('/user/**,/post/**')
 * ```
 * @param endpointGlobs
 */
function parseServicesFilterOption(
  endpointGlobs: string
): string[] | undefined {
  return endpointGlobs
    ? endpointGlobs
        .split(',')
        .filter((item: unknown): item is string =>
          Boolean(typeof item === 'string' && item.trim())
        )
    : undefined;
}

export type QraftCommandActionCallback = (
  options: {
    /**
     * Command inputs, e.g. `bin <input> [options]` where `<input>` is the `inputs` item
     */
    inputs: string[];
    /**
     * Command arguments, e.g. `bin <input> [options]` where `[options]` is the `args`
     */
    args: Record<string, any>;
    /**
     * Spinner instance
     */
    spinner: Ora;
    /**
     * OpenAPI services
     */
    services: Service[];
    /**
     * OpenAPI schema
     */
    schema: OpenAPISchemaType;
    /**
     * Output options
     */
    output: OutputOptions;
  },
  resolve: (files: GeneratorFile[]) => Promise<void>
) => void | Promise<void>;
