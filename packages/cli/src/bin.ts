import c from 'ansi-colors';
import { Command } from 'commander';
import fs from 'node:fs';
import { createRequire } from 'node:module';
import { sep } from 'node:path';
import process from 'node:process';
import { pathToFileURL } from 'node:url';
import ora, { Ora } from 'ora';

import { GeneratorFile } from './lib/GeneratorFile.js';
import { getDocumentServices } from './lib/open-api/getDocumentServices.js';
import { Service } from './lib/open-api/getServices.js';
import { OutputOptions } from './lib/OutputOptions.js';
import { writeGeneratorFiles } from './lib/writeGeneratorFiles.js';

export class QraftCommand extends Command {
  constructor() {
    super();

    this.usage('[input] [options]')
      .argument(
        '[input]',
        'Input OpenAPI Schema file path, URL (json, yml)',
        null
      )
      .requiredOption(
        '-o, --output-dir <path>',
        'Output directory for generated services'
      )
      .option(
        '-rm, --clean',
        'Clean output directory before generating services'
      )
      .option(
        '--filter-services <glob-pattern>',
        'Filter services to be generated by glob pattern. Eg: "/user/**,/post/**". See NPM `micromatch` package for more details.'
      )
      .option(
        '--postfix-services <string>',
        'Postfix to be added to the generated service name (eg: Service)'
      )
      .option(
        '--service-name-base <endpoint[<index>] | tags>',
        'Use OpenAPI Operation `endpoint[<index>]` path part (e.g.: "/0/1/2") or `tags` as the base name of the service.',
        'endpoint[0]'
      );
  }

  action(
    callback: (
      options: {
        spinner: Ora;
        services: Service[];
        output: OutputOptions;
        args: Record<string, any>;
      },
      resolveFiles: (files: GeneratorFile[]) => Promise<void>
    ) => void | Promise<void>
  ): this {
    return super.action(async (input, args) => {
      const spinner = ora('Starting generation').start();

      await callback(
        {
          spinner,
          services: await this.#getServices(input, args),
          args,
          output: {
            dir: normalizeOutputDirPath(args.outputDir),
            clean: args.clean,
          },
        },
        async function done(fileItems) {
          try {
            await writeGeneratorFiles({
              fileItems,
              spinner,
            });
            spinner.succeed(c.green('Services has been generated'));
          } catch (error) {
            spinner.fail(c.red('Error occurred during generation'));

            if (error instanceof Error) {
              console.error(c.red(error.message), c.red(error.stack ?? ''));
            }

            console.error(error);
            process.exit(1);
          }
        }
      );
    });
  }

  async #getServices(input: unknown, args: Record<string, any>) {
    const cwd = `${process.cwd()}/`;
    const { version: packageVersion, name: packageName } = JSON.parse(
      fs.readFileSync(
        createRequire(cwd).resolve('@openapi-qraft/cli/package.json'),
        'utf8'
      )
    );

    if (args.version) {
      console.info(`v${packageVersion}`);
      process.exit(0);
    }

    console.info(`âœ¨ ${c.bold(`${packageName} ${packageVersion}`)}`);

    const source =
      input && typeof input === 'string'
        ? new URL(input, pathToFileURL(cwd))
        : process.stdin;

    if (source === process.stdin && source.isTTY) {
      console.error(
        c.red(
          'Input file not found or stdin is empty. Please specify `--input` option or pipe OpenAPI Schema to stdin.'
        )
      );

      process.exit(1);
    }

    return await getDocumentServices({
      output: {
        postfixServices: args.postfixServices,
        serviceNameBase: args.serviceNameBase,
      },
      servicesGlob: parseServicesFilterOption(args.filterServices),
      source,
    });
  }
}

/**
 * Normalize an output directory path by adding trailing slash
 */
function normalizeOutputDirPath(outputDir: string): URL {
  return pathToFileURL(
    outputDir.endsWith(sep) ? outputDir : `${outputDir}${sep}`
  );
}

/**
 * Parse services filter option to array
 * @example
 * ```ts
 * parseServicesFilterOption('/user/**,/post/**')
 * ```
 * @param endpointGlobs
 */
function parseServicesFilterOption(
  endpointGlobs: string
): string[] | undefined {
  return endpointGlobs
    ? endpointGlobs
        .split(',')
        .filter((item: unknown): item is string =>
          Boolean(typeof item === 'string' && item.trim())
        )
    : undefined;
}
