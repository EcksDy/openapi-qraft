---
sidebar_position: 5
sidebar_label: useInfiniteQuery
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# useInfiniteQuery(...)

The Hook enables you to perform asynchronous data fetching operations with support for infinite scrolling scenarios.
It automatically handles loading states, caching, and data invalidation for paginated or infinitely loaded data.
See the TanStack [_useInfiniteQuery(...) ðŸŒ´_](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
documentation for more details.

```ts
const query = qraft.<service>.<operation>.useInfiniteQuery(
  parameters,
  infiniteQueryOptions,
  queryClient,
)
```

### Arguments

1. `parameters: Record<'path' | 'query' | 'header', Record<string, any>> | QueryKey | {}`
   - **Required** and strictly-typed âœ¨ parameters for the query
   - `parameters` will be used to generate the `QueryKey`
   - Instead of an object with `{path, query, header}`, you can pass a `QueryKey` as an array
     which is also strictly-typed âœ¨
   - If operation does not require parameters, you must pass an empty object `{}` for strictness

2. `infiniteQueryOptions?: UseInfiniteQueryOptions`
   - **Optional**, represents the options of the [_useInfiniteQuery(...) ðŸŒ´_](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery) Hook
     - `queryOptions.queryFn` could be provided to override the default `queryFn` used by Qraft
     - ~~`queryOptions.queryKey`~~ is not allowed, as it will be generated from `parameters`

3. `queryClient?: QueryClient`
   - **Optional** [_QueryClient ðŸŒ´_](https://tanstack.com/query/latest/docs/reference/QueryClient) to be used
   - _If not provided_
     - `QraftContext.queryClient` will be used if available
     - [_useQueryClient() ðŸŒ´_](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
       result will be used as a fallback

### Examples

<Tabs>
  <TabItem value="offset-based" label="Offset-based ðŸ¦Œ">
    ```tsx title="src/PostList.tsx"
    import { createAPIClient } from './api'; // generated by OpenAPI Qraft CLI

    const qraft = createAPIClient();

    function PostList() {
      /**
       * `qraft.posts.getPosts.useInfiniteQuery(...)` will execute the initial request:
       * ###
       * GET /posts?limit=10&page=1
       */
      const infiniteQuery = qraft.posts.getPosts.useInfiniteQuery(
        { query: { limit: 10 } },
        {
          getNextPageParam: (lastPage, allPages, lastPageParams) => {
            if (lastPage.length < 10) return; // if less than 10 items, there are no more pages
            return {
              query: {
                page: Number(lastPageParams.query?.page) + 1,
              },
            };
          },
          initialPageParam: {
            query: {
              page: 1, // will be used in initial request
            },
          },
        }
      );

      return (
        <div>
          {infiniteQuery.data?.pages.map((page, pageIndex) => (
            <ul key={pageIndex}>
              {page.map((post) => (
                <li key={post.id}>{post.title}</li>
              ))}
            </ul>
          ))}
          <button onClick={() => {
            // â¬‡ï¸Ž will execute GET /posts?limit=10&page=2
            infiniteQuery.fetchNextPage()
          }}>
            Load More
          </button>
        </div>
      );
    }
    ```
  </TabItem>
  <TabItem value="pagination-token-based" label="PaginationToken-based ðŸ¦‰">
    ```tsx title="src/DataExportList.tsx"
    import { createAPIClient } from './api'; // generated by OpenAPI Qraft CLI

    const qraft = createAPIClient();

    function DataExportList({ initial_pagination_token }: { initial_pagination_token?: string }) {
      /**
       * `qraft.dataExports.getDataExports.useInfiniteQuery(...)` will execute the initial request:
       * ###
       * GET /data_exports?pagination_token=<INITIAL_PAGINATION_TOKEN>
       * x-monite-version: 2023-09-01
       * x-monite-entity-id: 3e3e-3e3e-3e3e
       **/
      const infiniteQuery = qraft.dataExports.getDataExports.useInfiniteQuery(
        {
          header: {
            'x-monite-version': '2023-09-01',
            'x-monite-entity-id': '3e3e-3e3e-3e3e',
          },
        },
        {
          initialPageParam: {
            query: { pagination_token: initial_pagination_token }, // will be used in initial request
          },
          getNextPageParam: (lastPage, allPages, lastPageParam) => ({
            query: { pagination_token: lastPage.next_pagination_token },
          }),
          getPreviousPageParam: (firstPage, allPages, firstPageParam) => ({
            query: { pagination_token: firstPage.prev_pagination_token },
          }),
        }
      );

      return (
        <div>
          <button
            disabled={!infiniteQuery.hasPreviousPage}
            onClick={() => {
              /**
              * â¬‡ï¸Ž will execute the request:
              * GET /data_exports?pagination_token=<PREV_PAGINATION_TOKEN>
              * x-monite-version: 2023-09-01
              * x-monite-entity-id: 3e3e-3e3e-3e3e
              */
              infiniteQuery.fetchPreviousPage()
            }}
          >
            Load Previous
          </button>
          {infiniteQuery.data?.pages.map((page, pageIndex) => (
            <ul key={pageIndex}>
              {page.map((dataExport) => (
                <li key={dataExport.id}>{dataExport.name}</li>
              ))}
            </ul>
          ))}
          <button
            disabled={!infiniteQuery.hasNextPage}
            onClick={() => {
              /**
              * â¬‡ï¸Ž will execute the request:
              * GET /data_exports?pagination_token=<NEXT_PAGINATION_TOKEN>
              * x-monite-version: 2023-09-01
              * x-monite-entity-id: 3e3e-3e3e-3e3e
              */
              infiniteQuery.fetchNextPage()
            }}
          >
            Load More
          </button>
        </div>
      );
    }
    ```
  </TabItem>
</Tabs>
